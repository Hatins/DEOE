from turtle import forward
import torch
from torch import nn
import time
from math import log2
import numpy as np

import ipdb
import matplotlib.pyplot as plt
import cv2
import warnings
from torch.nn.init import _calculate_fan_in_and_fan_out
import math
from .corr_extract import corr_BasicLayer

class BaseConv(nn.Module):
    """A Conv2d -> Batchnorm -> silu/leaky relu block"""

    def __init__(
        self, in_channels, out_channels, ksize, stride, groups=1, bias=False, act="gelu", dropout = 0
    ):
        super().__init__()
        # same padding
        pad = (ksize - 1) // 2
        self.conv = nn.Conv2d(
            in_channels,
            out_channels,
            kernel_size=ksize,
            stride=stride,
            padding=pad,
            groups=groups,
            bias=bias,
        )
        self.bn = nn.BatchNorm2d(out_channels)
        if dropout > 0:
            self.dropout = nn.Dropout(dropout)
        else:
            self.dropout = None
        self.act = get_activation(act, inplace=True)  # 一个激活函数

    def forward(self, x):
        if self.dropout is None:
            return self.act(self.bn(self.conv(x)))
        else:
            return self.act(self.dropout(self.bn(self.conv(x))))

    def fuseforward(self, x):
        return self.act(self.conv(x))


class ResLayer(nn.Module):
    "Residual layer with `in_channels` inputs."

    def __init__(self, in_channels, act = "silu"):
        super().__init__()
        mid_channels = in_channels // 2
        self.layer1 = BaseConv(
            in_channels, mid_channels, ksize=1, stride=1, act=act
        )
        self.layer2 = BaseConv(
            mid_channels, in_channels, ksize=3, stride=1, act=act
        )

    def forward(self, x):
        out = self.layer2(self.layer1(x))
        return x + out
    
def _trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    # Values are generated by using a truncated uniform distribution and
    # then using the inverse CDF for the normal distribution.
    # Get upper and lower cdf values
    l = norm_cdf((a - mean) / std)
    u = norm_cdf((b - mean) / std)

    # Uniformly fill tensor with values from [l, u], then translate to
    # [2l-1, 2u-1].
    tensor.uniform_(2 * l - 1, 2 * u - 1)

    # Use inverse cdf transform for normal distribution to get truncated
    # standard normal
    tensor.erfinv_()

    # Transform to proper mean, std
    tensor.mul_(std * math.sqrt(2.))
    tensor.add_(mean)

    # Clamp to ensure it's in the proper range
    tensor.clamp_(min=a, max=b)
    return tensor


def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    r"""Fills the input Tensor with values drawn from a truncated
    normal distribution. The values are effectively drawn from the
    normal distribution :math:`\mathcal{N}(\text{mean}, \text{std}^2)`
    with values outside :math:`[a, b]` redrawn until they are within
    the bounds. The method used for generating the random values works
    best when :math:`a \leq \text{mean} \leq b`.

    NOTE: this impl is similar to the PyTorch trunc_normal_, the bounds [a, b] are
    applied while sampling the normal with mean/std applied, therefore a, b args
    should be adjusted to match the range of mean, std args.

    Args:
        tensor: an n-dimensional `torch.Tensor`
        mean: the mean of the normal distribution
        std: the standard deviation of the normal distribution
        a: the minimum cutoff value
        b: the maximum cutoff value
    Examples:
        >>> w = torch.empty(3, 5)
        >>> nn.init.trunc_normal_(w)
    """
    with torch.no_grad():
        return _trunc_normal_(tensor, mean, std, a, b)
    
def get_activation(name="gelu", inplace=True):
    if name == "silu":
        module = nn.SiLU(inplace=inplace)
    elif name == "relu":
        module = nn.ReLU(inplace=inplace)
    elif name == "lrelu":
        module = nn.LeakyReLU(0.1, inplace=inplace)
    elif name == "gelu":  # 高斯误差线性单元
        module = nn.GELU()
    else:
        raise AttributeError("Unsupported act type: {}".format(name))
    return module


class Focus(nn.Module):
    """Focus width and height information into channel space."""

    def __init__(self, in_channels, out_channels, ksize=1, stride=1, act="gelu"):
        super().__init__()
        self.conv = BaseConv(in_channels * 4, out_channels, ksize, stride, act=act)

    def patch_and_conv(self, x, conv):
        # shape of x (b,c,w,h) -> y(b,4c,w/2,h/2)
        patch_top_left = x[..., ::2, ::2]
        patch_top_right = x[..., ::2, 1::2]
        patch_bot_left = x[..., 1::2, ::2]
        patch_bot_right = x[..., 1::2, 1::2]
        x = torch.cat(
            (
                patch_top_left,
                patch_bot_left,
                patch_top_right,
                patch_bot_right,
            ),
            dim=1,
        )
        return conv(x)
    
    def forward(self, x):
        return self.patch_and_conv(x[...,0], self.conv)



class Temporal_Active_Focus_connect(Focus):  # bfm
    def __init__(self, in_channels, out_channels, ksize=1, stride=1, act="gelu"):
        time_channels = int(in_channels/2)
        self.embed_dim = 4
        reduce_times = int(log2(time_channels))  
        super().__init__(self.embed_dim * reduce_times, out_channels, ksize, stride, act)
        self.convs = nn.ModuleList()  # 
        self.relu = nn.ReLU()
        #self.dropouts = nn.ModuleList()

        for i in range(reduce_times):
            if i == 0:
                input_dim = 2
            else:
                input_dim = self.embed_dim
            self.convs.append(nn.utils.weight_norm(nn.Conv2d(int(input_dim * time_channels), int(self.embed_dim * time_channels / 2), 1, groups = int(time_channels / 2))))
            time_channels = time_channels / 2
            #self.dropouts.append(nn.Dropout2d(0.1))
            #self.relus.append(nn.ReLU)

        self.trans_up = nn.Conv2d(self.embed_dim * reduce_times, self.embed_dim * reduce_times * 4, 1)
        self.act = get_activation(act)
        self.drop = nn.Dropout2d(0.1)
        self.trans_down = nn.Conv2d(self.embed_dim * reduce_times * 4, self.embed_dim * reduce_times, 1)
        #self.dropouts.append(nn.Dropout2d(0.1))
        self.init_weights()

    def init_weights(self):
        for i in range(len(self.convs)):
            self.convs[i].weight.data.normal_(0, 0.01)
    
    def patch(self, x):
        # shape of x (b,c,w,h) -> y(b,4c,w/2,h/2)
        patch_top_left = x[..., ::2, ::2]   #[: : 2]指以2为步长， - 第一个位置为空，默认为0  第二个位置为空，默认为最后一个元素位置- 第三个元素为空，默认步长为1
        patch_top_right = x[..., ::2, 1::2]
        patch_bot_left = x[..., 1::2, ::2]
        patch_bot_right = x[..., 1::2, 1::2]
        x = torch.cat(
            (
                patch_top_left,
                patch_bot_left,
                patch_top_right,
                patch_bot_right,
            ),
            dim=1,
        )
        return x
    
    def forward(self, x):
        #########  Folding Layer  #########
        xout = []
        for i in range(len(self.convs)):
            x = self.relu(self.convs[i](x))#self.dropouts[i](self.relu(self.convs[i](x))) # 经过这个分组卷积之后通道数减半
            # 取最后四个
            xout.append(x[:,:self.embed_dim])
        x = torch.cat(xout, dim=1)  # bs, 12, 512, 640

        #########  MLP  #########
        xout = self.trans_up(x) # bs, 48, 512, 640
        xout = self.act(xout)  # 经过一个gelu激活函数
        xout = self.drop(xout)
        xout = self.trans_down(xout)  # bs, 12, 512, 640
        xout = self.drop(xout)
        x = x + xout  # 残差结构
        
        mask = self.patch(x)
        return self.conv(mask)

class Temporal_Active_Focus_corr(nn.Module):
    def __init__(self, in_channels, out_channels, ksize=1, stride=1, act="gelu"):
        super().__init__()
        time_channels = int(in_channels/2)
        reduce_times = int(log2(time_channels))
        embed_dim = 16
        self.embed_dim = embed_dim
        window_size = [2, 4, 4]
        self.deltas = [0, 5, 10, 25]
        #self.patch_embed = PatchEmbed3D(patch_size=patch_size, in_chans=2, embed_dim=embed_dim,norm_layer=None)
        self.patch_embed = nn.Conv2d(2, embed_dim, 2, 2)

        self.out_channels = out_channels

        self.convs = nn.ModuleList()
        self.relu = nn.ReLU()
        self.dropouts = nn.ModuleList()
        self.layer_norms = nn.ModuleList()
        for i in range(reduce_times):
            self.layer_norms.append(nn.LayerNorm(nn.LayerNorm((time_channels * embed_dim, 128, 160))))
            self.convs.append(nn.Conv2d(time_channels * embed_dim, time_channels * embed_dim, 1, groups = int(time_channels/(2 ** (i + 1)))))
            self.dropouts.append(nn.Dropout2d(0.1))
        
        self.patch_embed_ref = nn.Conv2d(2, embed_dim, 2, 2)

        self.convs_ref = nn.ModuleList()
        self.dropouts_ref = nn.ModuleList()
        self.layer_norms_ref = nn.ModuleList()
        for i in range(reduce_times-1):
            self.layer_norms_ref.append(nn.LayerNorm((time_channels * embed_dim, 128, 160)))
            self.convs_ref.append(nn.Conv2d(time_channels * embed_dim, time_channels * embed_dim, 1, groups = int(time_channels/(2 ** (i + 1)))))
            self.dropouts_ref.append(nn.Dropout2d(0.1))

        self.corr_extracts = nn.ModuleList()
        for i in range(reduce_times):
            self.corr_extracts.append(corr_BasicLayer(embed_dim * (2 ** i), len(self.deltas), window_size=window_size))

    def init_weights(self, pretrained=None):
        """Initialize the weights in backbone.
        Args:
            pretrained (str, optional): Path to pre-trained weights.
                Defaults to None.
        """
        def _init_weights(m):
            if isinstance(m, nn.Linear):
                trunc_normal_(m.weight, std=.02)
                if isinstance(m, nn.Linear) and m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            elif isinstance(m, nn.LayerNorm):
                nn.init.constant_(m.bias, 0)
                nn.init.constant_(m.weight, 1.0)
            for i in range(len(self.convs)):
                self.convs[i].weight.data.normal_(0, 0.01)
                self.convs_ref[i].weight.data.normal_(0, 0.01)
        self.apply(_init_weights)

    def forward(self, x):
        x = x.view(x.shape[0], int(x.shape[1]/2), 2, x.shape[2], x.shape[3])    #B, D, C, H, W
        deltas = torch.tensor(self.deltas).to(x.device)[None,:,None,None,None,None]
        x = x[:, None]  #B, 1, D, C, H, W
        x_ref = 1 - torch.log1p(torch.expm1((1 - x) * 8.7) + deltas) / 8.7  #B, R, D, C, H, W
        B, R, D, C, H, W = x_ref.shape
        x = x.view(B * D, C, H, W)
        x = self.patch_embed(x)
        x_ref = x_ref.view(B * R * D, C, H, W)
        x_ref = self.patch_embed_ref(x_ref)

        x = x.view(B, 1, D, self.embed_dim, int(H // 2), int(W // 2))
        x_ref = x_ref.view(B, R, D, self.embed_dim, int(H // 2), int(W // 2))

        for i in range(len(self.convs)):
            x = self.corr_extracts[i](x, x_ref)
            B, R, D, C, H, W = x_ref.shape
            x = x.view(B, D * C, H, W)
            x_ref = x_ref.view(B * R, D * C, H, W)
            x = self.dropouts[i](self.relu(self.convs[i](self.layer_norms[i](x))))
            x = x.view(B, 1, int(D / 2), 2 * C, H, W)
            if i < len(self.convs) - 1:
                x_ref = self.dropouts_ref[i](self.relu(self.convs_ref[i](self.layer_norms_ref[i](x_ref))))
                x_ref = x_ref.view(B, R, int(D / 2), 2 * C, H, W)
        
        x = x.view(B, self.out_channels, H, W)
        return x
    

class SPPBottleneck(nn.Module):
    """Spatial pyramid pooling layer used in YOLOv3-SPP"""

    def __init__(
        self, in_channels, out_channels, kernel_sizes=(5, 9, 13), activation="gelu"
    ):
        super().__init__()
        hidden_channels = in_channels // 2
        self.conv1 = BaseConv(in_channels, hidden_channels, 1, stride=1, act=activation)
        self.m = nn.ModuleList(
            [
                nn.MaxPool2d(kernel_size=ks, stride=1, padding=ks // 2)
                for ks in kernel_sizes
            ]
        )
        conv2_channels = hidden_channels * (len(kernel_sizes) + 1)
        self.conv2 = BaseConv(conv2_channels, out_channels, 1, stride=1, act=activation)

    def forward(self, x):
        x = self.conv1(x)
        x = torch.cat([x] + [m(x) for m in self.m], dim=1)
        x = self.conv2(x)
        return x